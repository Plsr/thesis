\chapter{Entwicklung der Anwendung}
\thispagestyle{fancy}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Gestaltung}
Generell nimmt die Gestaltung, wie bereits im Kapitel “Relevanz” deutlich wurde, eine zentrale Rolle in allen Projekte ein. Auch dieses Projekt bildet keine Ausnahme. Um eine gute Benutzbarkeit des Tools zu gewährleisten, ist eine solide Gestaltung unabdingbar. \\

Insgesamt ist die Anwendung eine sehr interaktive, in der Informationen eher Grafisch und über Interaktionen übertragen werden, als Beispielswiese über Text. Daher wurde hier bei der Gestaltung großer Wert darauf gelegt, klar zu kommunizieren, welche Bereiche interaktiv sind und welche Auswirkungen diese haben. \\
Weiterhin liegt hier der Fall vor, dass der Nutzer die Anwendung verwendet, um eine Gestaltung für sein Projekt zu erstellen. Der Fokus der Anwendung sollte daher, auch in der Gestaltung, darauf liegen, dem Nutzer die von ihm erstellte Gestaltung darzustellen. Die Anwendung sollte sich nicht un bestimmten Fällen (beispielsweise beim Auftreten eines Fehlers oder wenn eine Interaktion notwendig ist) in den Vordergrund stellen. \\

Dieses Vorgehen lässt sich anhand von zwei Beispielen gut verdeutlichen. Zum Einen seien hier die Fehlermeldungen im Bereich Typographie genannt. Diese sind in einem Auffälligen Gelb hinterlegt, dass nur an dieser Stelle (im Sinne von: Zum anzeigen von Fehlern) verwendet wird und dem Nutzer dafür schnell auffällt (s. Abb. ZXY).
Zum Anderen zeig die Auswahl von Farben gut, wie Interaktive Elemente der Anwendung gleichzeitig auch die Gestaltung des Nutzer zeigen können. Die Buttons zur Auswahl einer Farbe (s. Abb. ASH) bestehen hier lediglich aus der Farbe selbst, die Gestaltung der Anwendung wird hier als visuelle Zwischenebene also komplett entfernt. \\

Um die Design-Sprache der Anwendung nicht in den Vordergrund zu stellen wurde ein sehr schlichtes Farbschema verwendet, in dem die zwei Farben (Blau und Rot) nur zur Anzeige von Interaktivität verwendet wurden. Der größte Teil der Anwendung ist weiß gehalten, um sie die Gestaltung des Nutzers und dessen Entscheidungen besser in den Vordergrund stellen zu können.\\
Die beiden Farben haben dabei festgelegte Rollen: Blau zeigt Interaktivität innerhalb eines Schrittes der Anwendung an, Rot zeigt zwischen Schritten übergreifende Aktivitäten an (z.B. ein Button, der von einem Schritt zum nächsten führt).

\subsection{Abstände}
Um den Gedanken von innerhalb der Anwendung wiederverwendbaren Komponenten zu unterstützen liegt der Gedanke nahe, auch Abstände innerhalb der Gestaltung (und später auch in der Umsetzung) wiederverwendbar zu gestalten. Die Grundlage für diesen Gedanken lieferte ein Artikel von Nathan Curtis \cite{CurtisSpace16}. Der Artikel enthält zwei Grundgedanken:

\begin{enumerate}
  \item Die Größen von Abständen sollten sollten festgelegt und ihre Anzahl übersichtlich sein.
  \item Es gibt verschiedene Arten von Abständen, die die verschiedenen Größen auf unterschiedliche Weise einsetzen und kombinieren.
\end{enumerate}

Diese Gedanken wurden in der Gestaltung und Umsetzung des Projektes übernommen. Zunächst wurden die verschiedenen Abstände, aufbauend auf der von Curtis empfohlenen Basisgröße von 16px, definiert. Aufbauend auf der Basisgröße wurden anschließend Abstufungen in beide Richtungen
Erstellt, die nach Kleidergrößen, von XS bis XXL, benannt wurden.
Diese Abstufungen wurden in einer eigenen Datei als JavaScript-Objekt deklariert, so dass über die gesamte Anwendung hinweg diese festgelegten Größen verwendet werden können.

Curtis definiert 6 verschieden Arten von Abständen (vgl. Abb. ZXC), von denen 5 innerhalb der Anwendung als eigenständige Komponenten definiert wurden.
Die Komponenten nehmen die Größe des Abstandes als \verb|prop| in einer der definierten Kleidergrößen entgegen und erzeugen ein \verb|div|, dass die Abstände als padding oder margin anwendet.
Die Pixelwerte für die jeweilige Abstandsgröße erhält die Komponente dabei durch den Aufruf des für die Abstandsgrößen zuständigen JavaScript-Objekts (zum Beispiel \verb|spacing.l|). Alle diese Komponenten rendern außerdem die ihnen übergebenen Kinder, sodass eine Verwendung der \verb|SpacingInset| Komponente wie in Listing ASD möglich wird.

\begin{lstlisting}[caption=Beispielhafte Verwendung einer Komponente für Abstände, label=ListingSpacingInset]
  <SpacingInset size='l' >
    <h1> A Headline </h1>
    <p> Some Text </p>
  </SpacingInset>
\end{lstlisting}

Hier stellt sich die Frage, inwiefern es Sinn ergibt, Komponenten zu definieren, die eine ausschließlich visuelle Funktion haben.
So könnte deren Funktion auch innerhalb der CSS-Regeln von anderen Komponenten definiert und so ein übersichtlicheres Markup geschaffen werden.
Während der Arbeit stellte sich heraus, dass die Definition er Abstände als eigene Komponenten ein sehr einfaches Entwickeln von Interfaces ermöglichte.  Durch die eingegrenzten Möglichkeiten ist auch währen der Entwicklung ein testen von anderen Abständen sehr einfach möglich.
Weiterhin ist der Raum für Inkonsistenzen begrenzt, da die Abstände nur in den vorgegebenen Größen angegeben werden können. Dies wurde, gerade mit Blick auf die spätere Weiterentwicklung und Veröffentlichung, als ausreichend großer Vorteil angesehen, um eine Definition als eigenständige Komponente zu rechtfertigen.

\section{Besonderhieten im Technologie-Stack}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\subsection{Redux}
\begin{itemize}
  \item Trennung in verschiedene Sub-Stores
  \item Container
  \item Kein direktes dispatch in Components mehr
\end{itemize}

\subsection{React Storybooks}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\subsection{CSS-Architektur}
Für den Umgang mit CSS in React.js bieten sich verschiedene Möglichkeiten an. Nativ sind zwei Vorgehensweisen möglich: Anwenden von CSS über ausgelagerte Stylesheets (wie es in der Regel bei allen Webseiten gemacht wird) oder das verwenden von Inline-Styles.

Das verwenden von klassischen Stylesheets unterscheidet sich nicht sehr von der Verwendung bei einer statischen Webseite. Auch in React werden Klassennamen oder IDs festgelegt, über die dann im Stylesheet das Aussehen definiert wird (natürlich sind auch alle anderen validen CSS Selektoren anwendbar, Klassen und IDs seine hier nur als die populärsten Varianten beispielhaft genannt).
Auch die Verwendung von CSS-Präsporzessoren wie zum Beispiel SCSS stellt kein Problem dar, die kompilierung dieser Dateien muss lediglich in den Build-Prozess von React.js mit eingebunden werden. Eine simplifizierte Anwendung sähe beispielsweise wie folgt aus:

\begin{lstlisting}
<ReactComponent className='myClass'>
 Content
</ReactComponent>
\end{lstlisting}

Die kompilierte Dom-Node wäre dabei

\begin{lstlisting}
  <ReactComponent class='myClass'>
   Content
  </ReactComponent>
\end{lstlisting}

Und könnte im Stylesheet über

\begin{lstlisting}
  .myClass {
    color: red
  }
\end{lstlisting}

Angesprochen werden. Auch die Verwendung von Methodiken wie BEM oder SMACCS ist mit diesem Ansatz ohne Probleme möglich.
Für den Rahmen dieses Projektes wurde sich jedoch gegen diese Vorgehensweise entschieden, da bewusst ein Fokus auf eine komponentenbasierte Architektur gelegt werden sollte. Auch mit einer komponentenbasierten CSS-Architektur ist eine Komponente immer noch auf zwei Orte aufgeteilt: Die Funktion und das Markup, und das Styling.

[HIER LIESSE SICH AUCH DIE DISKUSSION NOCH AUSFÜHREN, DASS EIGENTLICH LEUTE LANGE DAFÜR GESPROCHEN HABEN, AUSSEHEN UND MARKUP ZU TRENNEN UND WARUM DAS HIER OKAY IST]

Um das Styling und die Funktion einer Komponente an einem Ort zu halten, bieten sich inline-styles an. Wie auch bei statischen Webseiten werden inline-styles direkt im \verb|style|-Attribut eines Elementes definiert. In React.js werden diese als JavaScript-Objekt übergeben. Eine Beispielhafte Anwendung findet sich in Quellcode XYZ

\begin{lstlisting}
  const styles = {
    backgroundColor: 'red',
    fontSize: '12px'
  }

  export default function myComponent(props) {
    return (
      <div styles=({styles}) >
  		{props.children}
  	  </div>
    )
  }
\end{lstlisting}

Auf den ersten Blick wirkt die Verwendung von inline-styles problematisch, vielleicht weil diese auf statischen Seiten viele Nachteile mit sich bringen. In einem Komponentenbasierten System wie React.js sind diese Nachteile jedoch nicht present. Durch die Komponentenbasierte Struktur und das damit einhergehende Ziel der Wiederverwendung von Komponenten, müssen Stylingänderungen auch hier nur an einer Stelle vorgenommen werden. Da jede Komponente nur für ihr eigenes Styling verantwortlich ist und nicht für das von Kindern, und auch kein CSS außerhalb der inline-styles verwendet wird (abgesehen von CSS-Reset und einigen globalen Regeln wie der Schriftart), kann es zu keinen Problemen mit der Spezifität von CSS-Regeln kommen.

Allerdings weisen inline-styles einige Limitierungen auf. So können beispielsweise keine Pseudo-Elemente wie \verb|:after| oder \verb|:before| verwendet werden. Auch das definieren von hover-states via \verb|:hover| wird nicht unterstützt.

[HIER NOCH VERWEIS AUF SPEZIFIKATION]

Zwar sind diese Limitierung zum aktuellen Stand des Projektes noch nicht von allzu großer Bedeutung, mit Blick auf eine Weiterentwicklung der Anwendung nach der Abschlussarbeit können diese in Zukunft jedoch eine größere Rolle spielen.
Um diese  Limitierungen zu umgehen, wurde das Framework Aphrodite verwendet. Das Framework erlaubt das Festlegen von styles innerhalb der Komponente ähnlich wie inline-styles, erzeugt aber für jedes neue style-objekt eine einzigartige CSS-Klasse, die via \verb|className| angewendet wird. Die Einzigartigkeit der Klasse wird durch das hinzufügen eines Hauses am Ende des Klassennamens gewährleistet.  Listing XYZ zeigt ein Beispiel

\begin{lstlisting}
  import React from 'react'
  import { StyleSheet, css } from 'aphrodite'

  function myComponent(props) {
  	<div className={css(styles.componentStyles)} >
  		{props.children}
  	</div>

  	const styles = StyleSheet.create({
  		componentStyles: {
  			color: 'blue'
  		}
  	})
  }
\end{lstlisting}

Die Struktur der style-objekte ist dabei der von inline-style-objekten gleich.

Mit der Verwendung von Aphrodite können also Aussehen und Funktion von Komponenten in der gleichen Datei gehalten werden, ohne dabei den Limitierungen von inline-styles zu unterliegen.

\section{Einstieg}
Auf die Konzeptionellen Aspekte des Einstiegs in die Applikation wurde bereits im Kapitel Einstieg in die Anwendung [VERWEIS] eingegangen. In diesem Abschnitt soll ergänzend  auf einige konkrete Aspekte der Gestaltung und Entwicklung eingegangen werden.

\subsection{Gestaltung}
Bereits im Kapitel Einstieg in die Anwendung [VERWEIS] wurde angesprochen, dass ein schrittweises Führen des Nutzers durch das Festlegen seines Entwicklungskontextes sinnvoll ist.
Hierfür wurde im ersten Schritt ein Wizard entworfen, der den Nutzer schrittweise durch die Knoten der verschiedenen Ebenen des Baumes in ABB XYC auf Seite ABC [VERWEIS]  führt.
Hierbei wurden Buttons mit Icons und Beschreibung verwendet, um eine Unterscheidung zwischen den verschiedenen Optionen für den Nutzer so einfach wie möglich zu machen [BELEG].
Am Ende des Wizards wird dem Nutzer der von ihm gewählte Entwicklungskontext noch einmal zusammengefasst dargestellt. Außerdem wird ihm die Option geboten, den Vorgang zu wiederholen, sollten die Ergebnisse nicht den gewünschten entsprechen.  Zum jetzigen Zeitpunkt ist  diese Funktion nicht unbedingt eine Notwendige, jedoch ist nicht ausgeschlossen, dass die Entwicklungskontexte zu einem späteren Zeitpunk zahlreicher oder tiefer verschachtelt werden.
Der Gestaltete Wizard kann ABB XZY entnommen werden [BILD FEHLT].

Hier wird auch die Verwendung der beiden Farben in der Applikation deutlich: Das Blau verändert Werte innerhalb eines einzelnen Schrittes, das Rot dient zu Navigation zwischen den verschiedenen Schritten der Applikation.

\subsection{Entwicklung}
Das Hauptaugenmerk in der Entwicklung lag in diesem Schritt im setzen der Scopes für die Anwendung. Da auf die Scopes in allen späteren Teilen der Anwendung zugegriffen werden können muss wurde schnell deutlich, dass diese im Application Sate, also dem Redux Store gehalten werden müssen. Hier stellte sich jedoch vor allem die Fragen nach der Datenstruktur der Scopes, wobei die Möglichkeiten auf die Haltung in einem Array oder als JavaScript Objekt begrenzt wurden.
Ein Array bietet dabei eine höhere Flexibilität, jedoch eine deutlich ungenauere Beschreibung der Scopes. So können andere Komponenten herausfinden, ob der für ihren Anwendungsfall relevanten Scope sich im Array der Scopes befindet, ohne Kenntnis darüber haben zu müssen, wie der Schlüssel des Scopes innerhalb des JavaScript Objektes lautet. Auch spielt die Länger der verschiedenen Äste des Baumes bei der Verwendung des Arrays eine weniger große Rolle, während bei der Verwendung eines Objektes immer auch geprüft werden muss, ob der key im store überhaupt vorhanden ist. Daher wurde an dieser Stelle ein Array verwendet.
[HIER SPÄTER NOCH MAL SCHAUEN, OB DAS NOCH STIMMT]

An dieser Stelle wird außerdem der in Kapitel Stateful \& Stateless [VERWEIS] angesprochene Unterschied zwischen Component State und Application State deutlich. Die Interaktion des Nutzers mit dem Wizard findet wie folgt statt: Der Nutzer wählt einen Scope aus, dieser wird von der Anwendung hervor gehoben. Mit einem Klick auf den “Next”-Button wird die Selektion gespeichert und darauf aufbauend neue Optionen angezeigt.
Abb XYZ [BILD FEHLT] zeigt noch einmal den Aufbau des Wizards in Verbindung mit den beteiligten Komponenten. Dabei ist nur der SetupContainer [NAME STIMMT NICHT] stateful, dieser kümmert sich um die Anzeige des vom Nutzer ausgewählten Scopes, der im state dieser Komponente gespeichert ist

\begin{lstlisting}
  constructor(props) {
    super(props)

    // shortended for readability

    this.state = {
      activeOption: false // currently active option, 'false' by default
  }
\end{lstlisting}

Da die aktuell gewählte Option nur für diese Komponente von Bedeutung ist, wird diese auch nicht in den Application State geschrieben. Bestätigt der Nutzer die Auswahl jedoch mit dem “Next”-Button, wird der Wert des aktuell aktiven Elements in den Store geschrieben.


\section{Typographie}
Wie bereits erwähnt wurde für den Bereich Typographie bereits im Rahmen des Praxisprojektes ein Proof of Concept entwickelt, der weite Teile der erarbeiteten Logik implementierte.
Im Folgenden soll daher vor allem auf die Bereiche eingegangen werden, die im Vergleich zum Praxisprojekt neu oder verändert sind. Vorrangig sind dies die Gestaltung und generelle Konzeption, sowie eine bessere Implementierung des Redux Stores und von React-Komponenten an sich.

\subsection{Konzeption}
Das Grundlegende Konzept zur Interaktion mit der Anwendung wurde aus dem Praxisprojekt übernommen, auch im Rahmen der Abschlussarbeit ist dieser Teil der Anwendung zweigeteilt: Zum einen wird das Ergebnis der Einstellungen in Form eines gesetzten Textes angezeigt, zum anderen werden verschiedene Möglichkeiten zur Manipulation des Textes in einer Tab-Navigation angezeigt.\\
Eine Andere Idee hier war die Möglichkeit zur direkten Interaktion mit Elementen. So hätte beispielsweise eine Überschrift angeklickt und deren Attribute daraufhin editiert werden können (Abb. ABC zeigt ein Beispiel). Gegen diesen Ansatz wurde sich aus verschieden Gründen entschieden.\\
Zum Einen wären für allgemeinere Einstellungen (wie z.B. die Wahl der Schriftart oder die Einstellung zur Laufweite des Textes gesonderte Bedienelemente nötig gewesen. Dem wurde eine geordnete Darstellung der Bedienelemente an einer zentralen Stelle vorgezogen. Damit einher wäre das Problem einer übersichtlichen Fehleranzeige gegangen: Es stellte sich als kompliziert dar, deutlich zu machen, zu welchem Attribut ein Fehler zugehörig ist.\\

Eine Konzeptuelle Neuerung stellt der Reset-Button dar. Dieser erlaubt ein einfaches zurücksetzen auf die Standardeinstellung und nimmt es dem Nutzer damit ab, im Zweifel 10 oder mehr Werte verändern zu müssen, um auf eine gute Einstellung zurück zu kommen.\\

Im Bezug auf die Standardeinstellungen stellt sich die Fragen: Welche Einstellungen sind hier zu bevorzugen? Es wurde sich bewusst gegen eine fehlerfreie Standardeinstellung entschieden, da es dem Nutzer nicht möglich ist, in der Anwendung einen Schritt vorwärts zu gehen, wenn noch Warnungen angezeigt werden. So kann sicher gestellt werden, dass der Nutzer sich auf jeden Fall mit dem Bereich Typographie befasst.\\
\textbf{[EVTL DARK PATTERN?]}\\
Auf der anderen Seite sollten die Standardeinstellung nicht zu viele Fehler enthalten, um den Nutzer nicht zu demotivieren.\\

Weiterhin wurde auf mobile Geräte als Zielmedium eingegangen: Hier funktioniert die Rechnung der optimalen Zeilenlänge nach Anzahl der Wörter nicht mehr (wenigstens nicht in einem Rahmen, der einen Lesbaren Text liefern kann), außerdem sind die Schriftgrößen anders zu bewerten.\\
\textbf{[ HIER NOCH SCHAUEN, WELCHE RICHTLINIEN ES DA GIBT ]}\\
Andere Werte, wie zum Beispiel der Zeilenabstand bleiben davon aber unberührt. Weiter Informationen zur Umsetzung der verschiedenen Bereiche für verschiedene Zielmedien finden sich im Kapitel Entwicklung.

\subsection{Gestaltung}
Wie bereits erwähnt wurde das grundlegende Layout aus dem Praxisprojekt beibehalten, jedoch wurde die Anordnung verändert: Statt übereinander sind die beiden Bereiche nun nebeneinander angeordnet. Dies hat den Effekt, dass sowohl die Bedienelemente, als auch der größte Teil des gesetzten Textes in einem Viewport dargestellt werden können.\\
Während der Geltung wurde versucht, den Fokus auf den zu setzenden Text zu legen und die Bedienelemente eher in den Hintergrund zu rücken. Durch die dunklere Hintergrundfarbe sollte aber auch eine klare Trennung der beiden Element nach ihren Aufgaben (Output oder Input) kommuniziert werden (Abbildung ASD zeigt ein High-Fidelity-Mockup dieses Bereiches).\\
\textbf{[BILD FEHLT]}\\
Außerdem wurde als Einstieg in den Bereich Typographie eine statische Seite entworfen, die kurz die Funktion des Bereiches aufzeigt (ABB. XYV zeigt eine schematische Ablauf der Interaktion). Zwar ist die Funktion dieses Bereiches recht eindeutig und simpel,  jedoch sollte es Ziel sein, den Nutzer so gut wie möglich während seiner Nutzung der Anwendung zu begleiten.\\
\textbf{[BILD FEHLT]}

\subsection{Entwicklung}
Die größte Neuerung in der Entwicklung im Vergleich zum Praxisprojekt war die Anwendung der Scopes, also der Zielmedien für die der Benutzer gestaltet. Hauptsächlich Interessant für den Bereich Typographie war dabei, ob der Nutzer für das Lesen am Bildschirm oder auf Papier gestaltet und das Mobile Betriebssystem, falls er eine Native Applikation entwickelt. Hauptsächlich wirken sich diese Scopes auf die wählbaren Schriftfamilien aus.\\

Die Umsetzung ist dabei recht simpel: Die verfügbaren Schriftfamilien sind als in einer Konstante gespeichert., sie sind dabei nach dem Namen ihres Scopes aufgeschlüsselt.

\begin{lstlisting}
  export const FONTS = {
    DISPLAY: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS'
    ],
    RESPONSIVE: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS'
    ],
    NOT_RESPONSIVE: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS'
    ],
    PAPER_DISPLAY: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS', 'Times New Roman', 'Georgia', 'Palatino'
    ],
    PAPER: [
      'Times New Roman', 'Georgia', 'Palatino'
    ],
    ANDROID: [
      'Roboto', 'Noto'
    ],
    IOS: [
      'San Francisco'
    ]
  }
\end{lstlisting}

In der entsprechenden Komponente, die ein Dropdown-Menu mit den verschiedenen Optionen darstellt, wir dann einfach das zum aktuellen Scope passende Array ausgewählt:

\begin{lstlisting}
  determineFontFamilies() {
    let scope = this.props.scopes[1]
    return FONTS[scope]
  }
\end{lstlisting}

Dieser Aufbau ermöglicht sowohl ein einfach hinzufügen und entfernen von Schriftfamilien, also auch das hinzufügen und entfernen von ganzen Scopes, was gerade mit Blick auf die Weiterentwicklung durch die Community interessant ist.\\

\textbf{[HIER FEHLT NOCH DER MOBILE SCOPE]}\\

Im Vergleich zum Praxisprojekt wurde weiterhin der Komponentenbasierte Aufbau verbessert. Währen im Praxisprojekt noch 21 Komponenten für die Darstellung verwendet wurden, konnte diese Zahl im rahmen der Abschlussarbeit auch 10 verringert werden.\\
\textbf{[ WIE KONNTE DAS ERREICHT WERDEN? ]}

Dies lässt sich beispielhaft an der Komponente aufzeigen, die verschiedene Möglichkeiten zur Manipulation von Attributen von Überschriften darstellt. In der Anwendung gibt es drei Überschriften verschiedener Ordnung, die in den Werten Größe,  Abstand nach oben und Abstand  nach unten verändert werden können. Im Praxisprojekt gab es hier für jede Überschrift verschiedener Ordnung eine eigene Komponente, im Rahmen der Abschlussarbeit konnte dies auf nur eine Komponente reduziert werden.\\
Der Hauptgrund hierfür ist das auslagern der Logik in andere Bereiche der Anwendung. So werden die Fehler nicht mehr innerhalb der Komponente errechnet, sondern lediglich dargestellt. Alle anderen Werte werden der Komponente beim Aufruf aus der Elternkomponente übergeben. Die prop area gibt dabei an, welchen Bereich des Stores diese Komponente verändert.

\begin{lstlisting}
  <HeadlineControls
  	onChange={this.props.setValueInArea}
  	area={'headline1'}
  	title={'Headline 1'}
  	componentErrors={errors.headline1}
  	{...this.props.headline1}
  />
\end{lstlisting}

\subsection{Ausblick}
Auch wenn hier eine solide und Marktfähige Version dieses Bereiches erstellt werden konnte, wurden währen der Entwicklung noch weitere Bereiche deutlich, die in Zukunft potentielle Verbesserung bieten können.\\
So wäre eine bessere visuelle Darstellung, welche Bereich beim Manipulieren eines Werte verändert werden, wünschenswert. Aktuell wird dies zwar bei Veränderungen in großen Schritten schnell deutlich, bei kleineren Schritten ist die Darstellung jedoch nicht optimal.\\
Weiterhin kann eine bessere Umsetzung für den Scope Responsive erreicht werden, Hier werden in der Regel mehrere Versionen von gesetztem Text benötigt.


\section{Farben}
Der Bereich Farben bietet einige neue Aspekte in der Entwicklung, vor allem, weil dieser Bereich im Praxisprojekt nur in der Theorie definiert wurde. Hier standen also weder Code noch Struktur zur Verfügung, auf denen aufgebaut werden konnte (die Ausnahme bilden einige Wireframes. Der folgende Abschnitt erläutert die Gedankengänge hinter der Konzeption und einige interessante Aspekte, die während der Entwicklung auftraten.

\subsection{Konzeption}
Dieser Bereich wird sehr stark vom Entwicklungskontext des Nutzers beeinflusst, vor allem weil beide abgebildeten mobilen Betriebssysteme sehr genaue Vorgaben im Bereich der zu verwendenden Farben machen.
Daher wurde dieser Bereich in zwei Schritten konzipiert: Das finden einer Grundfarbe und das finden einer Akzentfarbe.

Generell wurde die Idee aufgegriffen, Farben nach bestimmten Adjektiven wählen zu können. Dabei bietet sich, je nach Entwicklungskontext ein unterschiedlich vielfältiger Pool aus verfügbaren Farben.
Für alle Scopes außerhalb der mobilen Betriebssysteme sind die Farben nicht begrenzt, es steht dem Nutzer also Frei, jede hexadezimal darstellbare Farbe zu wählen. Für die Auswahl nach Adjektiven wurde die Zahl der Farben jedoch auch etwa 20 [ZAHL NOCH GENAU NACH SCHAUEN] reduziert, um hier eine gut Übersicht erhalten zu können. Eine Übersicht der Adjektive und Farben bietet ABB. XZY [BILD FEHLT]

[HIER FEHLT NOCH: WIE KOMMEN DIE ADJEKTIVE ZUSTANDE?]

Die beiden mobilen Betriebssysteme sind in ihren Guidelines hier deutlich restriktiver. Android definiert 18 [ZAHL NOCH MAL NACHSEHEN] Farben in verschiedenen Farbtönen. Den Guidelines folgend werden dem Nutzer hier die Farben im Farbton 500 dargestellt, aus denen er wählen kann.
In den Guidelines von iOS ist die Zahl der Farben mit 8 [ZAHL NOCH GUCKEN] am geringsten.
In beiden Fällen konnte aber Trotzdem eine Auswahl nach Adjektiven, wenn auch limitierter, weiterhin angeboten werden.

Im zweiten Schritt soll dem Nutzer dann beim finden einer Akzentfarbe geholfen werden. Auch hier unterscheiden sich die Vorgänge je nach Entwicklungskontext.
Im Bereich iOS fällt das finden einer Akzentfarbe ganz weg, das Apple eine Gestaltung mit nur einer Farbe (die in sich also eher eine Akzentfarbe als wie hier definiert eine Grundfarbe darstellt) nahe legt [VERWEIS].
Im Bereich Android gibt es in allen Farbtönen drei Abstufungen, die zur Verwendung als Akzentfarbe gedacht sind. Diese werden dem Nutzer hier zur Auswahl gestellt.
In allen anderen Bereichen ist die Anzahl der Farben, wie schon im ersten Schritt, nicht eingeschränkt.  Hier soll dem Nutzer die Möglichkeit geboten werden, Farbkombinationen in der Kontrasten Komplementär, Triadisch und Monochromatisch zu erstellen.
Zu den ermittelten Farben werden dann weiterhin weiss und schwarz hinzugefügt. Für Android sind auch diese definiert, in allen anderen Bereichen (iOS ausgenommen) sind diese als \verb|#ffffff| und \verb|#333333| festgelegt.

\subsection{Gestaltung}
[TBD]

\subsection{Entwicklung}

[HIER KÖNNTE NOCH EIN BISSCHEN MEHR EINLEITUNG]

Da die Berechnung der Farben im HSL-Farbmodell erfolgen sollten, die Anwendung aber an allen anderen Stellen mit der Hexadezimal-Darstellung arbeitet, müssen die Farben zunächst umgerechnet werden. Für die Umwandlung wurde die Bibliothek tinycolor [FUSSNOTE] verwendet, die aufgrund anderer verwendeter Bibliotheken schon im Projekt eingebunden war.
Die Bibliothek wandelt die Hexadezimaldarotellung in ein JavaScript-Objekt mit den Attributen hue, saturation, lightness und alpha am. Somit können einzelne Werte dieses Objektes problemlos manipuliert und anschließend wieder in einen Hexadezimal-String umgewandelt werden.

Die Grundlegende Logik zum errechnen von bestimmten Kontrasten wurde bereits im Praxisprojekt definiert: Für einen Komplementärkontrast muss der hue-Wert um 180° verändert werden, für ein triadisches Farbschema werden die Werte jeweils um 30° nach links und rechts verändert und für ein Monochromatische Farbschema können der lightness- und saturation-Wert von einer Menge von Farben verändert werden.
Im Folgenden sollen hier die konkreten Implementierungen dieser Berechnungen erläutert werden.

Die Berechnung der Komplementärfarbe erwies sich als recht einfach, hier musste lediglich darauf geachtet werden, dass der Hue-Wert nicht größer als 360° [VIELLEICHT AUCH 359?] werden durfte.


\begin{lstlisting}
  export function calculateCompelemntary(baseColor) {
    let complementary = Object.assign({}, baseColor)
    let hue = complementary.h

    hue += 180
    if (hue > 360) {
      hue -= 360
    }

    complementary.h = hue
    return complementary
  }
\end{lstlisting}

Ähnlich gestaltete es sich bei der Berechnung des triadischen Farbschemas. Hier musste der Hue-Wert lediglich um den gegebenen Gradwert erhöht oder verringert werden. Um die Farbschemata dynamischer zu gestalten, wurde sich dazu entschieden, hier nicht statische Werte von 30° zu verwenden, sondern diese dynamisch in einem Rahmen von 25° bis 35° zu generieren.

Deutlich komplexer gestaltet die Generierung von monochromatischen Farbschemata. Zum einen waren hier mehr Farben nötig, zum anderen können diese in den Werten Saturation und Lightness verändert werden. Weiterhin steht hier nicht fest, ob beide oder nur einer der Werte verändert werden soll, und wie die Veränderung aussieht. Auch hier wurde im Sinne der Dynamik auf zufallsgenerierte Zahlen zurück gegriffen.
In der Funktion wird zunächst zufällig bestimmt, welche Werte verändert werden. Sowohl Saturation als auch Lightness können Werte zwischen 0 und 1 annehmen. Im zweiten Schritt wurden also eine oder zwei Zufallszahlen zwischen 0 und 1 generiert (gerundet auch zwei Dezimalstellen).
Weiterhin muss gewährleistet werden, dass die einzelnen Farben sich nicht zu ähnlich sehen. Hier wurde eine Differenz von 0.1 als Minimum festgelegt (dabei reicht es, wenn einer der Werte außerhalb dieses Minimum liegt, um eine ausreichend hohe Differenz zwischen den Farben zu gewährleisten). Wird dieser Wert unterschritten, wird eine neue, zufällige Farbe generiert.

\begin{lstlisting}
  checkForSimilarColors(colors, candidate) {
    let similarValues = false
    for (var j = 0; j < colors.length; j++) {
      let saturationDifference = Math.abs(colors[j].s - candidate.s)
      let lightnessDifference = Math.abs(colors[j].l - candidate.l)

      if (saturationDifference < 0.1 && lightnessDifference < 0.1) {
        similarValues = true
      }
    }

    return similarValues
  }
\end{lstlisting}

\begin{lstlisting}
  changeValuesOfColor(values, color) {
    let manipulatedColor = Object.assign({}, color)
    // Switch case
    // Do the changes that need to be DropdownController
    switch (values) {
      case 0:
        // change lightness
        manipulatedColor.l = Math.random().toFixed(2)
        break
      case 1:
        // change Saturation
        manipulatedColor.s = Math.random().toFixed(2)
        break
      case 2:
        // change lightning and saturation
        manipulatedColor.l = Math.random().toFixed(2)
        manipulatedColor.s = Math.random().toFixed(2)
        break
      default:
        throw new 'Oops, seems like the randomizer messed something up.'
    }

    return manipulatedColor
  }
\end{lstlisting}

\begin{lstlisting}
  calculateMonochromaticColors(amount) {

    let colors = []

    for (var i = 0; i < amount; i++) {
      let currentColor = Object.assign({}, convertToHsl(this.props.baseColor))
      // Figure out if only one or two values should be changed
      // Random: 0 = Lightness, 1 = Saturation, 2 = Both
      let randomOption = Math.floor(Math.random() * 3)
      let changedColor = this.changeValuesOfColor(randomOption, currentColor)

      if (colors.length < 1) {
        colors.push(changedColor)
      } else {
        let similarColors = this.checkForSimilarColors(colors, changedColor)
        while (similarColors) {
          changedColor = this.changeValuesOfColor(randomOption, changedColor)
          similarColors = this.checkForSimilarColors(colors, changedColor)
        }
        colors.push(changedColor)
      }
    }

    return colors
  }
\end{lstlisting}

[HIER FEHLT NOCH DER AUSSCHLUSS VON SCHWARZ UND WEISS]


\section{Layouts \& Grid}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Offboarding}
Wie im Kapitel 2.1.2 “Ergebnisse der Benutzung”  bereits angesprochen, dient dieser letzte Schritt der Anwendung dazu, dem Nutzer eine Zusammenfassung der Ergebnisse zu liefern.
Da alle vom Nutzer getroffenen Entscheidungen im redux store gespeichert werden ist es kein Problem, hier eine Zusammenfassung dieser Daten darzustellen.
Diese Daten werden dem Nutzer in der aktuellen Version nach Themengebiet aufgeschlüsselt, untereinander dargestellt. Für die aktuell implementierten Gebiete und die daraus resultierende Menge an Informationen ist diese Lösung ausreichend, jedoch muss mit weiterer Entwicklung der Anwendung hier vermutlich auch ein anderer Lösungsansatz gefunden werden.

Als Anspruchsvoller stellte sich die Implementierung der Möglichkeit heraus, die Ergebnisse auch als PDF-Datei speichern zu können. Hier bieten sich verschiedene Möglichkeiten der PDF-Generierung an. Da die Applikation momentan eine reine Client-Anwendung ist, war die Auswahl an Möglichkeiten dadurch limitiert. Hier sollte nicht nur für die Möglichkeit der PDF-Generierung auch ein Server in die Anwendung eingespielt werden.

Die simpelste der Möglichkeiten ist ein Drucken als PDF Datei. Hierbei müsste für die Seite lediglich ein entsprechendes Stylesheet hinterlegt werden, dass das Layout für den Druck anpasst. Diese Lösung ist allerdings nur beschränkt verfügbar. Das Betriebssystem macOS bieten den Druck als PDF nativ an, das Betriebssystem Windows beispielsweise aber erst seit der neusten Version, Windows 10.
Eine weitere Möglichkeit stellt die Bibliothek html2canvas\footnotemark{} dar. Die Bibliothek erlaubt das Speichern von Seiten als Bilddateien. Die Verfügbarkeit ist hier deutlich höher als beim Drucken als PDF, jedoch bringt das Speichern als Bild einige Restriktionen mit sich. So können beispielsweise Werte nicht markiert und kopiert werden, was einen erhöhten Arbeitsaufwand für den Nutzer bedeutet.

\footnotetext{\url{https://github.com/niklasvh/html2canvas}}

Die Entscheidung file aus diesen Gründen hier auf die Bibliothek jsPDF\footnotemark{}. Diese erlaubt das erstellen von PDF-Dateien im Browser und auch das einfügen von DOM-Elementen in PDF-Dateien. Das einfügen bringt allerdings einige Limitierungen mit sich, so werden teilweise Texte, die zu tief in DOM-Elementen verschachtelt sind, nicht dargestellt. Daher wurde die PDF per hand zusammen gesetzt. jsPDF bietet dafür eine API, mit der verschiedene Elemente (wie Text oder geometrische Formen), unter Angabe der Position auf der x- und y-Achse, in die Datei eingefügt werden können. Listing XZY zeigt das beispielhafte einfügen einer Textzeile und das anschließende Speichern der Datei.

\footnotetext{\url{https://github.com/MrRio/jsPDF}}

Hier besteht jedoch ein hoher manueller Aufwand, der mit potentiellen weiteren Themengebieten in der Anwendung erneut evaluiert werden muss. Abb. XZY zeigt eine beispielhafte PDF-Datei, die von der Anwendung erstellt wurde.

Hier wurde außerdem deutlich, dass eine mögliche Nomenklatur des Projektes durch den Nutzer Vorteile hätte. So könnte dieser Name auf der PDF-Datei vermerkt werden, um diese eindeutiger zuordnen zu können. Außerdem wird dem Nutzer somit eher das Gefühl vermittelt, dass er einen Prozess durchläuft, an dessen Ende er ein Ergebnis für sein Projekt erzielt hat.

\section{Tests}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln
