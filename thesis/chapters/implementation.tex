\chapter{Entwicklung der Anwendung}
\thispagestyle{fancy}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Gestaltung}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\subsection{Wireframes \& Struktur}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\subsection{High Fidelity Mockups}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Besonderhieten im Technologie-Stack}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\subsection{Redux}
\begin{itemize}
  \item Trennung in verschiedene Sub-Stores
  \item Container
  \item Kein direktes dispatch in Components mehr
\end{itemize}

\subsection{React Storybooks}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\subsection{CSS-Architektur}
Für den Umgang mit CSS in React.js bieten sich verschiedene Möglichkeiten an. Nativ sind zwei Vorgehensweisen möglich: Anwenden von CSS über ausgelagerte Stylesheets (wie es in der Regel bei allen Webseiten gemacht wird) oder das verwenden von Inline-Styles.

Das verwenden von klassischen Stylesheets unterscheidet sich nicht sehr von der Verwendung bei einer statischen Webseite. Auch in React werden Klassennamen oder IDs festgelegt, über die dann im Stylesheet das Aussehen definiert wird (natürlich sind auch alle anderen validen CSS Selektoren anwendbar, Klassen und IDs seine hier nur als die populärsten Varianten beispielhaft genannt).
Auch die Verwendung von CSS-Präsporzessoren wie zum Beispiel SCSS stellt kein Problem dar, die kompilierung dieser Dateien muss lediglich in den Build-Prozess von React.js mit eingebunden werden. Eine simplifizierte Anwendung sähe beispielsweise wie folgt aus:

\begin{lstlisting}
<ReactComponent className='myClass'>
 Content
</ReactComponent>
\end{lstlisting}

Die kompilierte Dom-Node wäre dabei

\begin{lstlisting}
  <ReactComponent className='myClass'>
   Content
  </ReactComponent>
\end{lstlisting}

Und könnte im Stylesheet über

\begin{lstlisting}
  .myClass {
    color: red
  }
\end{lstlisting}

Angesprochen werden. Auch die Verwendung von Methodiken wie BEM oder SMACCS ist mit diesem Ansatz ohne Probleme möglich.
Für den Rahmen dieses Projektes wurde sich jedoch gegen diese Vorgehensweise entschieden, da bewusst ein Fokus auf eine komponentenbasierte Architektur gelegt werden sollte. Auch mit einer komponentenbasierten CSS-Architektur ist eine Komponente immer noch auf zwei Orte aufgeteilt: Die Funktion und das Markup, und das Styling.

[HIER LIESSE SICH AUCH DIE DISKUSSION NOCH AUSFÜHREN, DASS EIGENTLICH LEUTE LANGE DAFÜR GESPROCHEN HABEN, AUSSEHEN UND MARKUP ZU TRENNEN UND WARUM DAS HIER OKAY IST]

Um das Styling und die Funktion einer Komponente an einem Ort zu halten, bieten sich inline-styles an. Wie auch bei statischen Webseiten werden inline-styles direkt im \verb|style|-Attribut eines Elementes definiert. In React.js werden diese als JavaScript-Objekt übergeben. Eine Beispielhafte Anwendung findet sich in Quellcode XYZ

\begin{lstlisting}
  const styles = {
    backgroundColor: 'red',
    fontSize: '12px'
  }

  export default function myComponent(props) {
    return (
      <div styles=({styles}) >
  		{props.children}
  	  </div>
    )
  }
\end{lstlisting}

Auf den ersten Blick wirkt die Verwendung von inline-styles problematisch, vielleicht weil diese auf statischen Seiten viele Nachteile mit sich bringen. In einem Komponentenbasierten System wie React.js sind diese Nachteile jedoch nicht present. Durch die Komponentenbasierte Struktur und das damit einhergehende Ziel der Wiederverwendung von Komponenten, müssen Stylingänderungen auch hier nur an einer Stelle vorgenommen werden. Da jede Komponente nur für ihr eigenes Styling verantwortlich ist und nicht für das von Kindern, und auch kein CSS außerhalb der inline-styles verwendet wird (abgesehen von CSS-Reset und einigen globalen Regeln wie der Schriftart), kann es zu keinen Problemen mit der Spezifität von CSS-Regeln kommen.

Allerdings weisen inline-styles einige Limitierungen auf. So können beispielsweise keine Pseudo-Elemente wie \verb|:after| oder \verb|:before| verwendet werden. Auch das definieren von hover-states via \verb|:hover| wird nicht unterstützt.

[HIER NOCH VERWEIS AUF SPEZIFIKATION]

Zwar sind diese Limitierung zum aktuellen Stand des Projektes noch nicht von allzu großer Bedeutung, mit Blick auf eine Weiterentwicklung der Anwendung nach der Abschlussarbeit können diese in Zukunft jedoch eine größere Rolle spielen.
Um diese  Limitierungen zu umgehen, wurde das Framework Aphrodite verwendet. Das Framework erlaubt das Festlegen von styles innerhalb der Komponente ähnlich wie inline-styles, erzeugt aber für jedes neue style-objekt eine einzigartige CSS-Klasse, die via \verb|className| angewendet wird. Die Einzigartigkeit der Klasse wird durch das hinzufügen eines Hauses am Ende des Klassennamens gewährleistet.  Listing XYZ zeigt ein Beispiel

\begin{lstlisting}
  import React from 'react'
  import { StyleSheet, css } from 'aphrodite'

  function myComponent(props) {
  	<div className={css(styles.componentStyles)} >
  		{props.children}
  	</div>

  	const styles = StyleSheet.create({
  		componentStyles: {
  			color: 'blue'
  		}
  	})
  }
\end{lstlisting}

Die Struktur der style-objekte ist dabei der von inline-style-objekten gleich.

Mit der Verwendung von Aphrodite können also Aussehen und Funktion von Komponenten in der gleichen Datei gehalten werden, ohne dabei den Limitierungen von inline-styles zu unterliegen.

\section{Einstieg}
Auf die Konzeptionellen Aspekte des Einstiegs in die Applikation wurde bereits im Kapitel Einstieg in die Anwendung [VERWEIS] eingegangen. In diesem Abschnitt soll ergänzend  auf einige konkrete Aspekte der Gestaltung und Entwicklung eingegangen werden.

\subsection{Gestaltung}
Bereits im Kapitel Einstieg in die Anwendung [VERWEIS] wurde angesprochen, dass ein schrittweises Führen des Nutzers durch das Festlegen seines Entwicklungskontextes sinnvoll ist.
Hierfür wurde im ersten Schritt ein Wizard entworfen, der den Nutzer schrittweise durch die Knoten der verschiedenen Ebenen des Baumes in ABB XYC auf Seite ABC [VERWEIS]  führt.
Hierbei wurden Buttons mit Icons und Beschreibung verwendet, um eine Unterscheidung zwischen den verschiedenen Optionen für den Nutzer so einfach wie möglich zu machen [BELEG].
Am Ende des Wizards wird dem Nutzer der von ihm gewählte Entwicklungskontext noch einmal zusammengefasst dargestellt. Außerdem wird ihm die Option geboten, den Vorgang zu wiederholen, sollten die Ergebnisse nicht den gewünschten entsprechen.  Zum jetzigen Zeitpunkt ist  diese Funktion nicht unbedingt eine Notwendige, jedoch ist nicht ausgeschlossen, dass die Entwicklungskontexte zu einem späteren Zeitpunk zahlreicher oder tiefer verschachtelt werden.
Der Gestaltete Wizard kann ABB XZY entnommen werden [BILD FEHLT].

Hier wird auch die Verwendung der beiden Farben in der Applikation deutlich: Das Blau verändert Werte innerhalb eines einzelnen Schrittes, das Rot dient zu Navigation zwischen den verschiedenen Schritten der Applikation.

\subsection{Entwicklung}
Das Hauptaugenmerk in der Entwicklung lag in diesem Schritt im setzen der Scopes für die Anwendung. Da auf die Scopes in allen späteren Teilen der Anwendung zugegriffen werden können muss wurde schnell deutlich, dass diese im Application Sate, also dem Redux Store gehalten werden müssen. Hier stellte sich jedoch vor allem die Fragen nach der Datenstruktur der Scopes, wobei die Möglichkeiten auf die Haltung in einem Array oder als JavaScript Objekt begrenzt wurden.
Ein Array bietet dabei eine höhere Flexibilität, jedoch eine deutlich ungenauere Beschreibung der Scopes. So können andere Komponenten herausfinden, ob der für ihren Anwendungsfall relevanten Scope sich im Array der Scopes befindet, ohne Kenntnis darüber haben zu müssen, wie der Schlüssel des Scopes innerhalb des JavaScript Objektes lautet. Auch spielt die Länger der verschiedenen Äste des Baumes bei der Verwendung des Arrays eine weniger große Rolle, während bei der Verwendung eines Objektes immer auch geprüft werden muss, ob der key im store überhaupt vorhanden ist. Daher wurde an dieser Stelle ein Array verwendet.
[HIER SPÄTER NOCH MAL SCHAUEN, OB DAS NOCH STIMMT]

An dieser Stelle wird außerdem der in Kapitel Stateful \& Stateless [VERWEIS] angesprochene Unterschied zwischen Component State und Application State deutlich. Die Interaktion des Nutzers mit dem Wizard findet wie folgt statt: Der Nutzer wählt einen Scope aus, dieser wird von der Anwendung hervor gehoben. Mit einem Klick auf den “Next”-Button wird die Selektion gespeichert und darauf aufbauend neue Optionen angezeigt.
Abb XYZ [BILD FEHLT] zeigt noch einmal den Aufbau des Wizards in Verbindung mit den beteiligten Komponenten. Dabei ist nur der SetupContainer [NAME STIMMT NICHT] stateful, dieser kümmert sich um die Anzeige des vom Nutzer ausgewählten Scopes, der im state dieser Komponente gespeichert ist

\begin{lstlisting}
  constructor(props) {
    super(props)

	  // shortended for readability

    this.state = {
      activeOption: false // currently active option, 'false' by default
  }
\end{lstlisting}

Da die aktuell gewählte Option nur für diese Komponente von Bedeutung ist, wird diese auch nicht in den Application State geschrieben. Bestätigt der Nutzer die Auswahl jedoch mit dem “Next”-Button, wird der Wert des aktuell aktiven Elements in den Store geschrieben.


\section{Typographie}
Wie bereits erwähnt wurde für den Bereich Typographie bereits im Rahmen des Praxisprojektes ein Proof of Concept entwickelt, der weite Teile der erarbeiteten Logik implementierte.
Im Folgenden soll daher vor allem auf die Bereiche eingegangen werden, die im Vergleich zum Praxisprojekt neu oder verändert sind. Vorrangig sind dies die Gestaltung und generelle Konzeption, sowie eine bessere Implementierung des Redux Stores und von React-Komponenten an sich.

\subsection{Konzeption}
Das Grundlegende Konzept zur Interaktion mit der Anwendung wurde aus dem Praxisprojekt übernommen, auch im Rahmen der Abschlussarbeit ist dieser Teil der Anwendung zweigeteilt: Zum einen wird das Ergebnis der Einstellungen in Form eines gesetzten Textes angezeigt, zum anderen werden verschiedene Möglichkeiten zur Manipulation des Textes in einer Tab-Navigation angezeigt.\\
Eine Andere Idee hier war die Möglichkeit zur direkten Interaktion mit Elementen. So hätte beispielsweise eine Überschrift angeklickt und deren Attribute daraufhin editiert werden können (Abb. ABC zeigt ein Beispiel). Gegen diesen Ansatz wurde sich aus verschieden Gründen entschieden.\\
Zum Einen wären für allgemeinere Einstellungen (wie z.B. die Wahl der Schriftart oder die Einstellung zur Laufweite des Textes gesonderte Bedienelemente nötig gewesen. Dem wurde eine geordnete Darstellung der Bedienelemente an einer zentralen Stelle vorgezogen. Damit einher wäre das Problem einer übersichtlichen Fehleranzeige gegangen: Es stellte sich als kompliziert dar, deutlich zu machen, zu welchem Attribut ein Fehler zugehörig ist.\\

Eine Konzeptuelle Neuerung stellt der Reset-Button dar. Dieser erlaubt ein einfaches zurücksetzen auf die Standardeinstellung und nimmt es dem Nutzer damit ab, im Zweifel 10 oder mehr Werte verändern zu müssen, um auf eine gute Einstellung zurück zu kommen.\\

Im Bezug auf die Standardeinstellungen stellt sich die Fragen: Welche Einstellungen sind hier zu bevorzugen? Es wurde sich bewusst gegen eine fehlerfreie Standardeinstellung entschieden, da es dem Nutzer nicht möglich ist, in der Anwendung einen Schritt vorwärts zu gehen, wenn noch Warnungen angezeigt werden. So kann sicher gestellt werden, dass der Nutzer sich auf jeden Fall mit dem Bereich Typographie befasst.\\
\textbf{[EVTL DARK PATTERN?]}\\
Auf der anderen Seite sollten die Standardeinstellung nicht zu viele Fehler enthalten, um den Nutzer nicht zu demotivieren.\\

Weiterhin wurde auf mobile Geräte als Zielmedium eingegangen: Hier funktioniert die Rechnung der optimalen Zeilenlänge nach Anzahl der Wörter nicht mehr (wenigstens nicht in einem Rahmen, der einen Lesbaren Text liefern kann), außerdem sind die Schriftgrößen anders zu bewerten.\\
\textbf{[ HIER NOCH SCHAUEN, WELCHE RICHTLINIEN ES DA GIBT ]}\\
Andere Werte, wie zum Beispiel der Zeilenabstand bleiben davon aber unberührt. Weiter Informationen zur Umsetzung der verschiedenen Bereiche für verschiedene Zielmedien finden sich im Kapitel Entwicklung.

\subsection{Gestaltung}
Wie bereits erwähnt wurde das grundlegende Layout aus dem Praxisprojekt beibehalten, jedoch wurde die Anordnung verändert: Statt übereinander sind die beiden Bereiche nun nebeneinander angeordnet. Dies hat den Effekt, dass sowohl die Bedienelemente, als auch der größte Teil des gesetzten Textes in einem Viewport dargestellt werden können.\\
Während der Geltung wurde versucht, den Fokus auf den zu setzenden Text zu legen und die Bedienelemente eher in den Hintergrund zu rücken. Durch die dunklere Hintergrundfarbe sollte aber auch eine klare Trennung der beiden Element nach ihren Aufgaben (Output oder Input) kommuniziert werden (Abbildung ASD zeigt ein High-Fidelity-Mockup dieses Bereiches).\\
\textbf{[BILD FEHLT]}\\
Außerdem wurde als Einstieg in den Bereich Typographie eine statische Seite entworfen, die kurz die Funktion des Bereiches aufzeigt (ABB. XYV zeigt eine schematische Ablauf der Interaktion). Zwar ist die Funktion dieses Bereiches recht eindeutig und simpel,  jedoch sollte es Ziel sein, den Nutzer so gut wie möglich während seiner Nutzung der Anwendung zu begleiten.\\
\textbf{[BILD FEHLT]}

\subsection{Entwicklung}
Die größte Neuerung in der Entwicklung im Vergleich zum Praxisprojekt war die Anwendung der Scopes, also der Zielmedien für die der Benutzer gestaltet. Hauptsächlich Interessant für den Bereich Typographie war dabei, ob der Nutzer für das Lesen am Bildschirm oder auf Papier gestaltet und das Mobile Betriebssystem, falls er eine Native Applikation entwickelt. Hauptsächlich wirken sich diese Scopes auf die wählbaren Schriftfamilien aus.\\

Die Umsetzung ist dabei recht simpel: Die verfügbaren Schriftfamilien sind als in einer Konstante gespeichert., sie sind dabei nach dem Namen ihres Scopes aufgeschlüsselt.

\begin{lstlisting}
  export const FONTS = {
    DISPLAY: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS'
    ],
    RESPONSIVE: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS'
    ],
    NOT_RESPONSIVE: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS'
    ],
    PAPER_DISPLAY: [
      'Verdana', 'Arial', 'Tahoma', 'TrebuchetMS', 'Times New Roman', 'Georgia', 'Palatino'
    ],
    PAPER: [
      'Times New Roman', 'Georgia', 'Palatino'
    ],
    ANDROID: [
      'Roboto', 'Noto'
    ],
    IOS: [
      'San Francisco'
    ]
  }
\end{lstlisting}

In der entsprechenden Komponente, die ein Dropdown-Menu mit den verschiedenen Optionen darstellt, wir dann einfach das zum aktuellen Scope passende Array ausgewählt:

\begin{lstlisting}
  determineFontFamilies() {
    let scope = this.props.scopes[1]
    return FONTS[scope]
  }
\end{lstlisting}

Dieser Aufbau ermöglicht sowohl ein einfach hinzufügen und entfernen von Schriftfamilien, also auch das hinzufügen und entfernen von ganzen Scopes, was gerade mit Blick auf die Weiterentwicklung durch die Community interessant ist.\\

\textbf{[HIER FEHLT NOCH DER MOBILE SCOPE]}\\

Im Vergleich zum Praxisprojekt wurde weiterhin der Komponentenbasierte Aufbau verbessert. Währen im Praxisprojekt noch 21 Komponenten für die Darstellung verwendet wurden, konnte diese Zahl im rahmen der Abschlussarbeit auch 10 verringert werden.\\
\textbf{[ WIE KONNTE DAS ERREICHT WERDEN? ]}

Dies lässt sich beispielhaft an der Komponente aufzeigen, die verschiedene Möglichkeiten zur Manipulation von Attributen von Überschriften darstellt. In der Anwendung gibt es drei Überschriften verschiedener Ordnung, die in den Werten Größe,  Abstand nach oben und Abstand  nach unten verändert werden können. Im Praxisprojekt gab es hier für jede Überschrift verschiedener Ordnung eine eigene Komponente, im Rahmen der Abschlussarbeit konnte dies auf nur eine Komponente reduziert werden.\\
Der Hauptgrund hierfür ist das auslagern der Logik in andere Bereiche der Anwendung. So werden die Fehler nicht mehr innerhalb der Komponente errechnet, sondern lediglich dargestellt. Alle anderen Werte werden der Komponente beim Aufruf aus der Elternkomponente übergeben. Die prop area gibt dabei an, welchen Bereich des Stores diese Komponente verändert.

\begin{lstlisting}
  <HeadlineControls
  	onChange={this.props.setValueInArea}
  	area={'headline1'}
  	title={'Headline 1'}
  	componentErrors={errors.headline1}
  	{...this.props.headline1}
  />
\end{lstlisting}

\subsection{Ausblick}
Auch wenn hier eine solide und Marktfähige Version dieses Bereiches erstellt werden konnte, wurden währen der Entwicklung noch weitere Bereiche deutlich, die in Zukunft potentielle Verbesserung bieten können.\\
So wäre eine bessere visuelle Darstellung, welche Bereich beim Manipulieren eines Werte verändert werden, wünschenswert. Aktuell wird dies zwar bei Veränderungen in großen Schritten schnell deutlich, bei kleineren Schritten ist die Darstellung jedoch nicht optimal.\\
Weiterhin kann eine bessere Umsetzung für den Scope Responsive erreicht werden, Hier werden in der Regel mehrere Versionen von gesetztem Text benötigt.


\section{Farben}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Layouts \& Grid}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Offboarding}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Algorythmen}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln

\section{Tests}
Bei der Textgestaltung und automatischen Änderung von Abbildungsnummern, Querverweisen,
Seitenzahlen, Gliederungen, Literaturhinweisen etc. bietet sich der Rückgriff
auf moderne Textverarbeitungsprogramme an. Nutzen Sie diese zur besseren Lesbarkeit
und Strukturierung des Textes, aber vermeiden Sie überflüssige Spielereien. Da
besonders bei Textdokumenten mit eingebundenen Objekten wie Bildern, Formeln
