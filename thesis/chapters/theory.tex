\chapter{Theoretische Grundlagen}
\thispagestyle{fancy}
Das nachfolgende Kapitel soll die theoretischen Grundlagen erläutern, die für die Umsetzung der Anwendung von Bedeutung sind. Diese Grundlagen teilen sich in verschiedene Bereiche auf. Zum einen soll der Aufbau der Anwendung festgelegt werden. In diesem Beriech müssen außerdem einige Bereich noch Konzipiert werden. Auch dieser Prozess und dessen Ergebnisse sollen hier erläutert werden.
Weiterhin gilt es, die verschiedenen technischen Möglichkeiten der Umsetzung zu diskutieren. Abschließend findet sich ein konzeptioneller Einstieg in React.js und in einige damit verbundene und wichtige Bibliotheken, sowie eine Darstellung der Design-Prozesse.
\textbf{Die Einleitung stimmt nicht mehr}

\section{Diskussion verfügbarer Technologien}
Durch die in Kapitel ZXC definierten Konzepte können bereits einige Anforderungen an die Anwendung gefunden werden, die für die Umsetzung von Bedeutung sind.
Die Anwendung:

\begin{itemize}
  \item weist einen hohen Grad der Interaktivität auf
  \item benötigt kein Backend
  \item soll eine Webanwendung sein
\end{itemize}

Die Anwendung entspricht somit einer \textit{Rich Internet Application} wie sie George Lawton definiert:

\begin{quote}
  RIAs feature responsive user interfaces and interactive capabilities. This makes Internet-based programs easier to use and more functional, and also overcomes problems with traditional Web applications such as slow performance and limited interactivity \cite{lawton2008new}
\end{quote}

\subsection{Rich Internet Applications}
Die Idee, Webseiten dynamischer und interaktiver zu gestalten geht dabei fast so weit zurück wie die Idee des Internet selbst.

\begin{quote}
  Very early on, software engineers realized that the client-server architecture of the Web provided a powerful platform in which the browser could be a universal user interface to applications that may run locally or remotely on a server \cite{Jazayeri:2007:TWA:1253532.1254719}
\end{quote}

Um diese Interaktivität und Dynamik umzusetzen wurden zunächst Plattformen mit eigenen Laufzeitumgebungen genutzt. Lawton \cite{lawton2008new} nennt hier beispielsweise Microsoft Silverlight, Adobe Flash oder JavaFX.
Die Verwendung von eigenen Laufzeitumgebungen dieser Plattformen  bedeutete für den Nutzer jedoch,  dass dieser bestimmte Programme auf seinem Rechner oder Plugins in seinem Browser installieren musste, um zugriff auf die so gewonnene Interaktivität zu erhalten. Somit musste auf einen der größten Vorteile der Entwicklung von Webanwendungen verzichtet werden: Die Unnötigkeit einer Installation im Client für die Nutzung der Software.

Durch das Verabschieden von neuen Web-Standards wie HTML5 oder ECMAScript 6 können viele Funktionen der oben genannten Plattformen mittlerweile auch nativ, nur mit Hilfe des Browsers, abgebildet werden. So empfiehlt Adobe beispielsweise, Flash nicht für Funktionen zu nutzen, die auch mit Hilfe von HTML5 abgebildet werden können\footnotemark{}.

\footnotetext{siehe dazu \url{https://blogs.adobe.com/conversations/2015/11/flash-html5-and-open-web-standards.html}, zuletzt abgerufen am 11.08.2017}

Viele Facetten der Interaktivität können vor allem durch die Hilfe von JavaScript realisiert werden.

\subsection{Single Page Applications}
Das Prinzip der \textit{Single Page Applications (SPA)} lässt sich bereits an der Wortbedeutung gut erkennen: Es handelt sich um Anwendungen, die auf einer einzigen HTML-Seite ausgeliefert werden.
Mikowski und Powell definieren SPAs als

\begin{quote}
  […] an application delivered to the browser that doesn’t reload the page during use. Like all applications, it’s intended to help the user complete a task, such as “write a document” or “administer a web server.” We can think of an SPA as a fat client that’s loaded from a web server. \cite{MikowskiPowell201309}
\end{quote}

Single Page Applications können somit als Untereinheit der Rich Internet Applications bezeichnet werden.
Eine der ältesten Möglichkeiten, eine Single Page Application zu realisieren stellt AJAX dar. AJAX erlaubt das nachladen von Inhalten  vom Server, ohne, dass die Seite des Clients neu geladen werden muss \cite{paulson2005building}. Da eine Anforderung an die zu entwickelnde Anwendung aber die Absenz eines Backends ist, kann diese Möglichkeit zur Umsetzung ausgeschlossen werden.

Aufgrund der Möglichkeiten, die mit den bereits erwähnten, neuen Web-Standards einhergehen, entstanden in den letzten Jahren jedoch viele JavaScript-Frameworks, die sich auf die Entwicklung von Single Page Applications spezialisieren.

\subsection{Vue.js}
Zuerst wurde Vue.js im Dezember 2013 veröffentlicht. Mittlerweile ist Vue.js in der zweiten Version zugänglich.
Vue beschreibt sich selbst in der Einführung der Documentation wie folgt:

\begin{quote}
  Vue […] is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is very easy to pick up and integrate with other libraries or existing projects. \cite{VueIntro}
\end{quote}

Vue.js ist dabei (wie die anderen hier behandelten Libraries und Frameworks auch) Komponentenbasiert. Um das User Interface effektiv zu aktualisieren, verwendet es eine Virtual DOM. Dieser ist eine Abstraktion des Normalen DOMs, wie ihn das w3c spezifiziert \cite{w3cDOM}:

\begin{quote}
  The Document Object Model (DOM) is a programming API for HTML and XML documents. It defines the logical structure of documents and the way a document is accessed and manipulated.
\end{quote}

Der DOM im klassischen Sinn ist also eine Baumdarstellung der Elemente, die sich beispielsweise in einer HTML-Datei wiederfinden. Abb. XYZ zeigt eine beispielhafte Darstellung einer HTML-Datei im Browser, die Struktur ihrer Elemente und die Darstellung als DOM-Baum.
Der Virtual DOM wird von Frameworks wie Vue.js dafür verwendet, Änderungen am DOM performances durchführen zu können. Die genaue Funktionsweise sei im Rahmen dieser Arbeit nicht erläutert,  jedoch beschreibt die Vue.js Dokumentation die Vorgänge wie folgt \cite{VueTemplate}:

\begin{quote}
  Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal amount of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.
\end{quote}

Für das Darstellen von Inhalten verwendet Vue.js eine Templating-Engine, Erweiterungen wie Routing oder Verwaltung des Zustandes der Anwendung müssen über externe Bibliotheken eingefügt werden.

\subsection{Angular.js}
Das von Google Entwickelte Angular.js ist das älteste der hier behandelten Frameworks. Es wurde zuerst im Oktober 2010 veröffentlicht und ist ebenfalls in der 2. Version angelangt.\\
Insgesamt ist Angular deutlich komplexer als  Vue.js und React. Dies zeigt sich zum Einen beispielsweise durch die inkludierung von Routing (wenn auch nicht im angular core package), zum Anderen aber auch die die deutlich Komplexere Architektur, die unter anderem aus Teilen wie Modulen, Komponenten und Templates besteht. Auch hier wird also eine Templating-Engine verwendet.

\subsection{React.js}
React.js wurde im Juli 2013 von Facebook veröffentlicht.\\
Wie Vue.js verwendet auch React.js einen Virtual DOM. Auch wenn die Implementierung sich hier unterscheiden sollte, ist das Prinzip das Gleiche.
Anders als Vue.js und Angluar.js verwendet React keine Templating Engine, React Applikationen sind daher als komplett in JavaScript geschrieben. Hier wird also HTML in JavaScript geschrieben, und nicht JavaScript in HTML, wie es im klassischen Sinne geschieht.
Ähnlich wie Vue.js ist auch React.js in seiner Funktionalität sehr komprimiert, Funktionen wie Routing oder Application State müssen also über externe Bibliotheken eingebunden werden.

\section{Einstieg in React.js}
Der Folgende Abschnitt soll einen überblick über wichtige Konzepte und Vorgehensweisen bei der Entwicklung mit React.js geben. Ziel soll es dabei sein, genug Wissen zu vermitteln, um die später in dieser Arbeit gezeigten Codebeispiele verstehen zu können.\\
Dieser Abschnitt wird auf das Konzept von Komponenten im Allgemeinen sowie deren Verwendung in und in React.js eingehen und einige Grundlagen in der Auszeichnungssprache JSX vermitteln. Weiterhin werden die Übertragung von Daten und Zuständen innerhalb von React Komponenten behandelt.

\subsection{Komponenten}
Der Komponentenbasierte Aufbau ist eines der Hauptaugenmerke von React.js. Komponenten werden auf der offiziellen React.sj-Website \footnotemark als der wichtigsten Merkmale aufgeführt und Gackenheimer \cite[S. 28]{Gackenheimer201509} nennt sie einen der Hauptbestandteile einer React-Anwendung. \\
Dieser Abschnitt beschäftigt sich mit dem Aufbau, der Verwendung, den verschiedenen Formen und den Besonderheiten von Komponenten in React. \\
Natürlich kann und soll es nicht Ziel sein, einen umfassenden überblick über alle Informationen zu geben, die mit Komponenten in React in Verbindung stehen. Daher soll im Folgenden vorrangig auf in der Umsetzung als am relevantesten empfundene Aspekte eingegangen werden.
\footnotetext{\url{https://facebook.github.io/react/}}


\subsubsection{Was ist eine Komponente?}
Bevor auf die Besonderheiten von Komponenten in React.js eingegangen wird, soll im Folgenden kurz ein Überblick über das Konzept der Komponente an sich gegeben werden.

Das Oxford Dictionary definiert eine Komponente als

\begin{quote}
  A part or element of a larger whole […]
\end{quote}

Gerade im Bezug auf Softwareentwicklung werden Komponenten aber noch einige weitere Eigenschaften zugeschrieben. So schreiben \cite{Szyperski200211} über Komponenten in der Softwareentwicklung:


\begin{quote}
  One thing can be stated with certainty: components are for composition. […] Composition enables prefabricated “things” to be reused by rearranging them in ever-new composites.
\end{quote}

Das Hauptaugenmerk bei der Entwicklung einer Komponente in der Softwareentwicklung sollte also auf der Möglichkeit der Wiederverwendbarkeit innerhalb der Anwendung liegen. Dabei sollte der Ort für die Wiederverwendung keine Rolle spielen. Eine Komponente sollte also unabhängig von ihrer Umgebung die gleichen Ergebnisse liefern \cite{de2001interface}:


\begin{quote}
  It does not constrain the environment but describes the behavior of the component in an arbitrary environment: “for all inputs x and y, if y $\neq$ 0, then the output is z = x/y“
\end{quote}

\subsubsection{Komponenten in React.js}
Jede Komponente in React ist eine Subklasse der Basisklasse \verb|React.Component| \cite{ReactCom}.
Konzeptuell besitzt jede Komponente in React einen Lifecycle. Die offizielle Dokumentation \cite{ReactCom} beschreibt in diesem Lifecycle drei Zustände:

\begin{enumerate}
  \item Mounting
  \item Updating
  \item Unmounting
\end{enumerate}

\textbf{Mounting} beschreibt dabei den Vorgang des erstellen der Komponente und des einfügens in den DOM. Funktionen, die beim Mounting aufgerufen werden, werden also nur ein einziges mal im gesamten Lifecycle aufgerufen (die Ausnahme bildet dabei die Funktion \verb|render()|, die auch beim Update Ereignis aufgerufen wird).

Ein \textbf{Update} wird durch die Veränderung von \verb|props| oder \verb|state| herbeigeführt. Der Auslöser für ein Update kann dabei also sowohl von der Komponente selbst, als auch von einer anderen Komponente kommen, die diese Komponente aufgerufen hat.

\textbf{Unmounting} wird unmittelbar vor dem entfernen der Komponente aus dem DOM aufgerufen.

Abbildung XYZ zeigt eine Schematische Darstellung des Lifecycle einer React Komponente.

Für jeden dieser verschiedenen Zustände bietet die Basisklasse \verb|React.Component| verschiedene Funktionen an, die überschreiben werden können um diese zu verwenden. Die Funktionen werden dabei entweder vor oder nach dem jeweiligen Ereignis im Lifecycle aufgerufen.
Die einzelnen Funktionen sollen im Folgenden nicht im einzelnen erläutert werden, da diese ausreichend Dokumentiert sind.

Für das Arbeiten mit Komponenten in React ist weiterhin das Konzept der \verb|props| und des \verb|state| relevant.
\verb|props| sind Daten, die von einer Komponente zur anderen übergeben werden können. Diese können beliebige JavaScript Objekte oder Primitive sein, somit können auch Referenzen auf Funktionen and Kind-Komponenten übergeben werden.  Die Kind-Komponente kann dann via \verb|this.props.propName| auf die ihr mitgegebenen props zugreifen.
Listing XZY verdeutlich dieses Prinzip

\begin{lstlisting}
  class Parent extends REact.Component {
  	calculateSomething() {
  		// Claculates something
  		return result
  	}

  	render() {
  		let result = this.calculateSomething()

  		return (
  			<Child value={result} />
  		)
  	}
  }

  class Child extends React.Component {
  	render() {
  		return (
  			<div>{this.props.value}</div>
  		)
  	}
  }
\end{lstlisting}

Das Prinzip des \verb|state| wird im Kapitel Stateless \& Stateful auf Seite \pageref{chap:stateless} näher erläutert.

\subsubsection{Stateful \& Stateless}
\label{chap:stateless}
Komponenten in React.js können entweder Stateful oder Stateless sein. Wie der Name bereits vermuten lässt, haben diese Komponenten entweder  einen state, oder nicht.\\
Der state in React.js beschreibt den Zustand eine Komponente. Hier findet sich auch eines der Hauptfeatures von React.js: Ändert sich der state einer Komponente, so wird diese Komponente neu gerendert, also auch das User Interface aktualisiert um den neuen Zustand darzustellen. Der state kann (und sollte) dabei durch das Aufrufen der Funktion \verb|setState()| geändert werden. Das nachfolgende Codebeispiel zeigt eine simple Komponente, die clicks auf einen Button zählt:

\begin{lstlisting}
  class ClickCounter extends React.Component{
  	constructor(props) {
  		super(props)

  		this.state = {clicks: 0}
  	}

    handleClick() {
  		this.setState((prevState) => {
    			return {clicks: prevState.clicks + 1};
  		});
  	}

  	render() {
  		return (
  			<button onClick={this.handleClick}>Click me!</button>
  			{this.state.clicks}
  		)
  	}
  }
\end{lstlisting}

Hier passiert folgendes: Im Konstruktor der Komponente (der nur ein mal, beim initialen rendern aufgerufen wird) wird die initiale Anzahl der Clicks im state auf 0 gesetzt.
Die Komponente rendert ein \verb|<buttton>| element und die Anzahl der gezahlten Klicks. Wird der Button geklickt, wird die Funktion \verb|handleClick()| in der Komponente aufgerufen. Diese Funktion erhöht die Anzahl der Klicks im state um eins. Durch den aktualisierten state wird auch die Komponente neu gerendert, so dass nun auch die neue Klickzahl angezeigt wird. \\

Die Komponente im obigen Beispiel ist also Stateful. Wie schon früher in diesem Kapitel erwähnt, ist es aber Ziel der Komponentenbasierten Softwareentwicklung, wiederverwendbare Komponenten zu schreiben.\\
Diese Komponente ließe sich an jeder Stelle der Anwendung wiederverwenden, an der Klicks über einen Button gezählt werden müssen, jedoch ist die Wahrscheinlichkeit hoch, dass diese Anwendungsfall eher selten vorkommt. Außerdem ist die Wahrscheinlichkeit recht hoch, dass ein Button oder ein Element zur Darstellung von Werten in der Anwendung häufiger verwendet werden (natürlich würde eine einfache Darstellung wie im obigen Beispiel kein Sinn ergeben, für dieses Beispiel soll daher eine komplexere Darstellung der Daten angenommen werde, beispielsweise durch eine Progress-Bar).
Eigentlich liegen hier also drei Komponenten vor: Eine Komponente, die Logik enthält und zwei weitere, die lediglich Daten darstellen, somit also stateless sind.\\

Mit dem release von React 0.14\footnotemark wurde eine simplifizierte Schreibweise für stateless components eingeführt. Die beiden Komponente aus dem Beispiel könnten somit wie folgt definiert werden:

\footnotetext{\url{https://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html}}

\begin{lstlisting}
  export default function Button = (props) => {
  	return (
  		<button onClick={props.onClick}>Click me!</button>
  	)
  }
\end{lstlisting}

und

\begin{lstlisting}
  export default function ValueDisplay = (props) => {
  	return (
  		<div>{props.value}</div>
  	)
  }
\end{lstlisting}

Die Werte für diese Komponenten werden ihnen in der Oberkomponente als \verb|props| übergeben:

\begin{lstlisting}
  class ClickCounter extends React.Component{
  	constructor(props) {
  		super(props)

  		this.state = {clicks: 0}
  	}

    handleClick() {
  		this.setState((prevState) => {
    			return {clicks: prevState.clicks + 1};
  		});
  	}

  	render() {
  		return (
  			<Button onClick={this.handleClick} />
  			<ValueDisplay value={this.state.clicks} />
  		)
  	}
  }
\end{lstlisting}

Ziel muss es also sein, so viele Komponenten wie möglich so klein wie möglich, optimaler Weise mit nur einer einzigen Aufgabe zu schreiben, um die Wiederverwendbarkeit zu erhöhen.

\textbf{Hier irgendwo eine Referenz auf Beispielhafte Verwendung von Komponenten in der Anwendung}

\subsection{JSX}
Hier soll nicht tiefer auf die Kompilierung und Prozess von JSX eigegangen werden, jedoch ist JSX ein elementarer Teil von React-Anwendung und sei der Vollständigkeit halber hier erwähnt. Im folgenden soll vorrangig auf die Unterschiede zwischen JSX und HTML und die Besonderheiten und Pitfalls während der Entwicklung mit JSX eingegangen werden.

JSX ist eine (eigens für die Verwendung mit React entwickelte) Syntax-Erweiterung für JavaScript, die es Erlaubt, HTML-Ähnliche Tags in der \verb|render()|-Methode von React Komponenten zu verwenden (der Einsatz von JSX konnte bereits in den vorhergehenden Beispielen beobachtet werden).
JSX ist dabei lediglich eine syntaktische Verschönerung der Funktion \verb|React.createElement(component, props, ...children)| \cite{ReactJSX}, auch wenn die Syntax der HTML-Syntax ähnlich sieht, werden alle JSX-Elemente in die genannte JavaScript-Funktion kompiliert.

JSX unterstütz die Deklaration von regulären HTML-Elementen, als auch die von React-Komponenten. Unterschieden werden die beiden Varianten dabei nach Groß- und Kleinschreibung, wobei React-Komponenten groß- und reguläre HTML-Elemente klein geschrieben sind.
React-Komponenten können dabei, wie oben bereits erwähnt, \verb|props| mitgegeben werden.
Der Schritt von HTML zu JSX stellt in der Entwicklung keine große Herausforderung dar.
Der wichtigste Punkt ist die Verwendung von \verb|class|. Auch bei der Entwicklung mit React werden für DOM-Elemente häufig Klassen vergeben. Da JSX-Code aber in JavaScript kompiliert wird, kann das in JavaScript reservierte Wort\footnotemark \verb|class|  nicht verwendet werden. Es muss stattdessen auf \verb|className| zurück gegriffen werden.

\footnotetext{\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar}}


\section{Einstieg in Redux}
Redux\footnotemark  erlaubt die zentrale Verwaltung des state bzw. des Zustandes der Anwendung im sogenannten redux store. Dabei ersetzt der redux store nicht zwangsweise den state von einzelnen Komponenten. Es gibt keine genauen Richtlinien dafür, wann ein state in der Komponente und wann im redux store verwaltet werden sollte, jedoch bietet es sich als Richtlinie an, nur Zustände im redux store zu verwalten, die von mehr als nur einer einzigen Komponente verwendet werden.
Redux besteh dabei aus drei Grundbestandteilen: Dem \textit{Store}, den \textit{Actions} und den \textit{Reducern}.

\footnotetext{\url{http://redux.js.org/}}

Wie bereits erwähnt wird im Store der Zustand der Anwendung verwaltet. Der \textit{Store} an sich kann dabei ein beliebiges JavaSCript Objekt (Funktionen ausgenommen) oder Primitiv sein. Für diesen \textit{Store} hat die Anwendung nur Leserecht, er darf nicht direkt manipuliert werden. Für eine Änderung des Stores werden die anderen beiden Bestandteile benötigt.

\textit{Actions} beschreiben Aktionen und sind JavaScript Objekte. Sie müssen mindestens einen \verb|type| Parameter haben, der beschreibt, welche Aktion ausgeführt werden soll. Weiterhin können sie Daten definieren, die für die Änderung des stores von Bedeutung sind. Das absenden dieser actions ist der einzige weg, mit dem die Anwendung den \textit{Store} verändern kann.

\textit{Reducer} definieren, wie der Zustand der Anwendung je nach erhaltener Aktion verändert werden muss. Ist beispielsweise der \verb|type| einer \textit{Action} \verb|INCREMENT_DOWNLOADS_COUNT| kann im \textit{Reducer} definiert sein, dass beim erhalten dieser action das Feld \verb|downloadsCount| im \textit{Store} um eins erhöht werden muss.

Ein \textit{Provider} macht den \textit{Store} dann für Container-Komponenten verfügbar. Diese verteilen den \textit{Store} und die actions als props an representative Komponenten. Ändert sich der \textit{Store} erhalten die entsprechen betroffenen Komponenten also neue \textit{props} und werden somit neu gerendert.
Abb XYZ zeigt einen schematischen Ablauf einer Aktualisierung des redux stores.

Detailliertere Erläuterungen zur Implementation von redux im Rahmen der Anwendung finden sich in Kapitel ABC.
